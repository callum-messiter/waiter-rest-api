<!DOCTYPE html>
<html lang="en">
	<head>
		<!-- THIS IS A SIMPLE DEMONSTRATION OF THE LIVEKITCHEN SYSTEM USING WEBSOCKETS. IT IS MEANT FOR CLIENT-APP DEVELOPERS TO 
			 GRASP HOW TO INTERFACE WITH THE LIVEKITCHEN ON THEIR END.
		-->
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>McDonald's - LiveKitchen!</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
		<!-- Latest compiled and minified CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css"
		integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
		<link rel="stylesheet" href="css/main.css">
		</head>
		<body>
			<script>
				window.onload=function(){
					// 1) Get the restaurantId from the server before doing anything else. This will probably be returned upon login, along with the userId. Later, for users with multiple restaurant, they will have a username-and-password combination per restaurant, but each 'account' will be assigned to the same email address if they so desire
					const restaurantId = 'mcdonalds';
					const orderName = 'order-' + restaurantId;
					
					// 2) Create a socket to the server - now we're listening for events 
					const socket = io.connect("http://localhost:3000/");

					// This stuff is just for visualising the LiveKitchen system
					const accept = document.getElementById('accept');
					const output = document.getElementById('output');

					// 3) We listen for events that are specific to our restaurant. On the server, the order it receives from a client (iOS app) will contain the restaurantId. The server will then emit the event to us - the web app - using the same naming convention as orderName. As such, each restaurant will only receive orders placed to *their* kitchen
					socket.on(orderName, function(order) {
						window.customerId = order.customerId;
						window.orderId = order.orderId;
						// 4) Upon receiving an order, we will add it to our orders list
						output.innerHTML += '<p><strong>' + order.customerId + '</strong></p>';
					});

					// 5) The web app should also emit events: an update of the order's status. If, for example, the chef accepts the user's order, the new status will be emitted to the server (api), and to the user (iOS).
					accept.addEventListener('click', function(customerId) {
						const orderStatus = {
							orderId: window.orderId,
							customerId: window.customerId,
							restaurantId: restaurantId,
							status: 'accepted' // see the Orders.statuses array, and use this on the client-side
						}
						socket.emit('orderStatusUpdate', orderStatus);
					});

					// 6) The web app will need to manage the state of the kitchen at all times. If the page is reloaded, all live orders should still be visisible. Anytime the LiveKitchen screen is reloaded, it might grab all live orders from the database to hard refresh the kitchen, in case of any "order disappearances"

					// In our state we would keep a record of all live orders. Each order will have an orderId and a userId (associated to the customer). Then we can emit an event with a name that is specific to this user, so that only they receive the status updates
				}
			</script>
			<div class="container">
				<div class="row justify-content-center title-row">
					<div class="col-xs-10">
						<h1 class="welcome">McDonald's - LiveKitchen!</h1>
						<button id="accept">Accept order</button>
						<button id="reject">Reject order</button>
						<button id="complete">Order is complete</button>
						<div id="output"></div>
					</div>
			</div>
  	</body>
</html>